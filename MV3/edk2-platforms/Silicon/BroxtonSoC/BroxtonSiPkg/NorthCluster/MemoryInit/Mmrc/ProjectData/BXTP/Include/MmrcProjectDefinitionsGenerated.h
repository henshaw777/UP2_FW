/** @file
  File name:    MmrcProjectDefinitionsGenerated.h
  Input File:   BXTP_SOC.xlsx

  THIS FILE IS AUTO-GENERATED BY THE MMRC TOOL. DO NOT CHANGE THIS CODE.

  If edits are needed in this file, they must be done via the MMRC tool.

  If there is additional project-specific data required by the MMRC, it
  can be placed in MmrcProjectDefinitions.h, which is used for non-tool-generated
  data

  Includes all hard defines specific to a project. Things like
  the maximum number of channels, ranks, DIMMs, etc, should be included
  here. This file needs to be included by most MMRC components,
  including Mmrc.h.

  Copyright (c) 2005 - 2017, Intel Corporation. All rights reserved.<BR>

  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php.

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.

**/

#ifndef _MMRCPROJECTDEFINITIONSGENERATED_H_
#define _MMRCPROJECTDEFINITIONSGENERATED_H_



//
// Maximum number of blueprints
//
#define MAX_BLUEPRINTS                                     2

//
// Maximum number of Instances
//
#define MAX_INSTANCE_PORTS                                 50
//

//
// This project contains 64 bit variables.
//
#define USE_64_BIT_VARIABLES                               1
//
// Channels
//
#define MAX_CHANNELS                                       4
//
// DIMMS Per Channel
//
#define MAX_DIMMS                                          1
//
// Ranks Per Channel
//
#define MAX_RANKS                                          2

//
// Max Strobes Per Channel
//
#define MAX_STROBES                                        9
//
// Max Strobes Per Channel when ECC is disabled
//
#define MAX_STROBES_NON_ECC                                (MAX_STROBES-1)

//
// Max number of ranks for a single DIMM
//
#define MAX_RANKS_PER_DIMM                                 2

//
// Number of DQ per BL
//
#define MAX_BITS                                           8
//
// Command groups per channel.
//
#define MAX_CMDS                                           2
//
// Control Groups Per Channel.
//
#define MAX_CTLS                                           2
//
// Clock Groups Per Channel.
//
#define MAX_CLKS                                           2
//
// Major Version
//
#define VERSION_MAJOR                                      89
//
// Minor Version
//
#define VERSION_MINOR                                      20
//
// Print MRC functions as they execute
//
#define CAPSULESTRINGS                                     0
//
//
//
#define ERROR_MESSAGES                                     1
//
// Use CPGC for training
//
#define CPGC_API                                           1
//
// Lowest address bit for rank selection during training
//
#define RANK_SHIFT_BIT                                     25
//
// Debug message output to serial or console
//
#define DEBUG_MSG                                          1
//
// Enable training algorithms
//
#define TRAINING_ALGOS                                     1
//
// Number of Samples to take for Rcvn/FWL.
//
#define NUMSAMPLES                                         8
//
// Number of consecutive samples to pass for RCVN/FWL.
//
#define SAMPLETHRESH                                       5
//
// Dithering check for stability for RCVN/FWL.
//
#define DITHER                                             5
//
// Receive enable training
//
#define RECEIVE_ENABLE                                     1
//
// Number of 2x for LP3
//
#define RCVN_PREAMBLE_CNTR_LP3                             1
//
// Number of 2x for LP4
//
#define RCVN_PREAMBLE_CNTR_LP4                             2
//
// Number of 2x for DDR3
//
#define RCVN_PREAMBLE_CNTR_DDR3                            1
//
// Number of ps for LP3
//
#define RCVN_PREAMBLE_OFFSET_LP3                           0
//
// Number of ps for LP4
//
#define RCVN_PREAMBLE_OFFSET_LP4                           0
//
// Number of ps for DDR3
//
#define RCVN_PREAMBLE_OFFSET_DDR3                          0
//
// Starting point for the half clock during receive enable.
//
#define RCVN_INITIAL2XVAL_LP3                              12
//
// Starting point for the half clock during receive enable.
//
#define RCVN_INITIAL2XVAL_LP4                              13
//
// Starting point for the half clock during receive enable.
//
#define RCVN_INITIAL2XVAL_DDR3                             14
//
// Enable Rank-2-Rank Training for LP3
//
#define RCVN_RANK2RANK_ON_LP3                              0
//
// Enable Rank-2-Rank Training for LP4
//
#define RCVN_RANK2RANK_ON_LP4                              0
//
// Enable Rank-2-Rank Training for DDR3
//
#define RCVN_RANK2RANK_ON_DDR3                             0
//
// Large Step size as percentage of the Half Clock.
//
#define RCVN_LARGE_STEP                                    25
//
// Step size during second phase of receive enable
//
#define RCVN_MEDIUM_STEP                                   5
//
// Step size during final phase of receive enable
//
#define RCVN_SMALL_STEP                                    1
//
// Fine write leveling training
//
#define FINE_WRITE_LEVELING                                1
//
// Enable Rank-2-Rank Training for LP3
//
#define FWL_RANK2RANK_ON_LP3                               0
//
// Enable Rank-2-Rank Training for LP4
//
#define FWL_RANK2RANK_ON_LP4                               0
//
// Large Step size as percentage of the Half Clock.
//
#define FWL_LARGE_STEP                                     25
//
// Step size during second phase of receive enable
//
#define FWL_MEDIUM_STEP                                    5
//
// Step size during final phase of receive enable
//
#define FWL_SMALL_STEP                                     1
//
// Coarse write leveling training
//
#define COARSE_WRITE_LEVELING                              1
//
// Number of cks to push out DQS
//
#define CWL_CLK_PUSHOUT                                    3
//
// Step size for each DQ Testing (LP4)
//
#define CWL_DQ_STEP                                        5
//
// Early Command Training
//
#define EARLY_COMMAND_TRAINING                             1
//
// Vref to perform ECT.
//
#define ECT_LP4_VREF                                       0x60
//
// Width and Height of the search matrix.
//
#define ECT_TILE_WIDTH                                     9
//
// Use CPGC or DRAM_CMD to enter CBT mode (LP3 Only CA-2N Mode)
//
#define ECT_ENTERCBT_CPGC                                  1
//
// Enable the pushout of the CCC flag
//
#define PUSHOUT_CCC                                        1
//
// Pushout by the number of 2x clcoks.
//
#define PUSHOUT_VALUE                                      2
//
// Early Read Training
//
#define EARLY_READ_TRAINING                                1
//
// After finding final edge, amount of dithering to test.
//
#define ERT_DITHER                                         0
//
// Nominal RdVref for ERT training.
//
#define ERT_VREF_LPDDR4                                    0xA
//
// Nominal RdVref for ERT training.
//
#define ERT_VREF_LPDDR3                                    0x1f
//
// Nominal RdVref for ERT training.
//
#define ERT_VREF_DDR3                                      0x1f
//
// Larger step size to find edge.
//
#define ERT_LARGESTEP                                      10
//
// Medium step size to find edge.
//
#define ERT_MEDIUMSTEP                                     5
//
// Small step size to find edge.
//
#define ERT_SMALLSTEP                                      1
//
// Victim/aggressor read training
//
#define READ_TRAINING                                      1
//
// P/N Independent Training
//
#define RT_PN_ENABLED                                      1
//
// If no PBD set to 0xFF else use format RANK_SHARED|KNOB_SHARED | BIT_SHARED | BIT_CONTROL
//
#define RT_BIT_SHARING                                     RANK_SHARED|KNOB_SHARED | BIT_CONTROL|CALCULATE_BIT
//
//
//
#define RT_BYTE_SHARING                                    BIT_SHARED|KNOB_SHARED
//
//
//
#define RT_PERBIT_ENABLED                                  1
//
//
//
#define RT_NUM_EYEMASKS                                    2
//
//
//
#define RT_EYEMASK0_PI                                     15
//
//
//
#define MAX_POWER_KNOBS                                    1
//
//
//
#define RT_EYEMASK_VREF                                    3
//
//
//
#define RT_EYEMASK1_PI                                     15
//
//
//
#define RT_STEP1_VREFMIN                                   0
//
//
//
#define RT_STEP1_VREFMAX                                   63
//
//
//
#define RT_STEP1_VREFSTEP                                  2
//
//
//
#define RT_STEP1_VREFSTART_LP3                             25
//
//
//
#define RT_STEP1_VREFSTART_LP4                             0
//
//
//
#define RT_STEP1_VREFSTART_DDR3                            25
//
//
//
#define RT_STEP1_3_PISTEPLARGE                             1
//
//
//
#define RT_STEP1_3_PISTEPMEDIUM                            0
//
//
//
#define RT_STEP1_3_PISTEPSMALL                             0
//
//
//
#define RT_CTLE_MIN                                        0
//
//
//
#define RT_CTLE_MAX                                        0
//
//
//
#define RT_CTLE_STEP                                       2
//
//
//
#define RT_CTLE_ENABLE                                     0
//
//
//
#define RT_STEP2_VREFMIN                                   0
//
//
//
#define RT_STEP2_VREFMAX                                   63
//
//
//
#define RT_STEP2_VREFSTEP                                  5
//
//
//
#define RT_STEP3_VREFSAMPLES                               3
//
// Pi/VREF center estimate weight
//
#define RT_STEP1_PICENTER_MINWEIGHT                        2
//
//
//
#define RT_STEP1_PICENTER_MIDWEIGHT                        3
//
//
//
#define RT_STEP1_PICENTER_MAXWEIGHT                        5
//
//
//
#define RT_CTLE_SHARED                                     RANK_SHARED|KNOB_SHARED | BIT_SHARED | BIT_CONTROL
//
//
//
#define RT_STEP2_PISAMPLES                                 3
//
// Advance Write Training
//
#define WRITE_TRAINING                                     1
//
//
//
#define WT_PERBIT_ENABLED                                  1
//
// 0xff
//
#define WT_BIT_SHARING                                     RANK_SHARED|KNOB_SHARED | BIT_CONTROL
//
//
//
#define WT_BYTE_SHARING                                    BIT_SHARED|KNOB_SHARED
//
//
//
#define WT_NUM_EYEMASKS                                    2
//
//
//
#define WT_EYEMASK0_PI                                     40
//
//
//
#define WT_EYEMASK_VREF                                    3
//
//
//
#define WT_EYEMASK1_PI                                     1
//
// No Vref Control
//
#define WT_STEP1_VREFMIN_DDR3                              0
//
// Vref Control
//
#define WT_STEP1_VREFMIN_LP3                               0
//
// 10th of percange of VDDQ; THESE ARE NOT USED
//
#define WT_STEP1_VREFMIN_LP4                               100
//
// No Vref Control
//
#define WT_STEP1_VREFSTEP_DDR3                             1
//
// Vref Control
//
#define WT_STEP1_VREFSTEP_LP3                              2
//
// 10th of percange of VDDQ
//
#define WT_STEP1_VREFSTEP_LP4                              8
//
// NO Vref Control
//
#define WT_STEP1_VREFMAX_DDR3                              1
//
// Vref Control
//
#define WT_STEP1_VREFMAX_LP3                               63
//
// 10th of percange of VDDQ; THESE ARE NOT USED
//
#define WT_STEP1_VREFMAX_LP4                               420
//
// No Vref Control
//
#define WT_STEP1_VREFSTART_DDR3                            0
//
// Vref Control
//
#define WT_STEP1_VREFSTART_LP3                             0
//
// 10th of percange of VDDQ; THESE ARE NOT USED
//
#define WT_STEP1_VREFSTART_LP4                             420
//
// 10th of percange of VDDQ
//
#define WT_STEP1_VREFSTEP                                  8
//
// 10th of percange of VDDQ; THESE ARE NOT USED
//
#define WT_STEP1_VREFMAX                                   420
//
// 10th of percange of VDDQ; THESE ARE NOT USED
//
#define WT_STEP1_VREFSTART                                 420
//
//
//
#define WT_STEP1_3_PISTEPLARGE                             1
//
//
//
#define WT_STEP1_3_PISTEPMEDIUM                            0
//
//
//
#define WT_STEP1_3_PISTEPSMALL                             0
//
//
//
#define WT_STEP2_VREFMIN                                   400
//
//
//
#define WT_STEP2_VREFMAX                                   4
//
// No Vref Control
//
#define WT_STEP2_VREFSTEP_DDR3                             1
//
// Vref Control
//
#define WT_STEP2_VREFSTEP_LP3                              5
//
// Vref Control
//
#define WT_STEP2_VREFSTEP_LP4                              421
//
//
//
#define WT_STEP3_VREFSAMPLES                               3
//
//
//
#define WT_STEP1_PICENTER_MINWEIGHT                        2
//
//
//
#define WT_STEP1_PICENTER_MIDWEIGHT                        3
//
//
//
#define WT_STEP1_PICENTER_MAXWEIGHT                        5
//
//
//
#define WT_VREFOVERRIDE_VALUE                              37
//
//
//
#define WT_VREF_OVERRIDE_ENABLE                            1
//
//
//
#define VDDQ                                               1100
//
//
//
#define LDO_TARGET                                         850
//
//
//
#define LDO_ENABLED                                        0
//
//
//
#define RON                                                35
//
//
//
#define ODT                                                999999
//
//
//
#define RTWT_SIM                                           0
//
//
//
#define PERIODIC_TRAINING                                  1
//
// Enable RMT Support
//
#define RMT                                                1
//
//  OKAY to DELETE ** set to 0 on release code ** Peter put here just for sim purposes
//
#define RMT_WRITE_CHECKPOINT                               0
//
// default RMT burst length
//
#define RMT_NUMBURSTS                                      13
//
// default RMT loop count
//
#define RMT_LOOPCOUNT                                      10
//
// Loopcount for production RMT test
//
#define RMT_PRODUCTION_LOOPCOUNT                           7
//
// Numbursts for production RMT test
//
#define RMT_PRODUCTION_NUMBURSTS                           7
//
// CPGC RMT Logging Enable
//
#define RMT_BIT_ERROR_LOGGING_ENABLE                       0
//
// Loopcount for PPV RMT test
//
#define RMT_PPV_LOOPCOUNT                                  7
//
// Numbursts for PPV RMT test
//
#define RMT_PPV_NUMBURSTS                                  13
//
// Enable Per-Bit margin
//
#define RMT_PER_BIT_MARGIN                                 1
//
// max # of retries (w/JEDEC) if fail after RMT test
//
#define POST_RMT_RETRIES                                   5
//
// jump to other training postcode from RMT command loop
//
#define RMT_JUMP_POSTCODES                                 1
//
// Enable or disable support of the production RMT margin check
//
#define RMT_PRODUCTION_MODE_SUPPORT                        1
//
// Late command training
//
#define COMMAND_TRAINING                                   1
//
// Test all memory at the end of MRC
//
#define MEMORY_TEST                                        0
//
// Initialize ECC at the end of MRC
//
#define ECC_SCRUB                                          0
//
// Display all DDRIO delays at the end of MRC
//
#define PHYVIEW_TABLE                                      1
//
// Display memory controller timings
//
#define TIMING_TABLE                                       1
//
// Display function calls
//
#define MRC_FLOW                                           0
//
// Enable BDAT table for publishing memory information in ACPI
//
#define BDAT                                               0
//
// Detect DIMMs via SPD reads
//
#define DETECT_DIMMS                                       0
//
// Enable PUNIT communication via mailbox
//
#define PUNIT_MAILBOX                                      0
//
// Use ODT input table from KIT team
//
#define ODT_TABLE                                          0
//
// Are minus 1 selects supported on this project?
//
#define TX_DQS_MINUS1_SUPPORT                              0
//
// Are minus 1 selects supported on this project?
//
#define TX_DQ_MINUS1_SUPPORT                               0
//
// Display register names with dumping
//
#define DUMP_REGISTER_NAMES                                0
//
// Display register fields when dumping registers
//
#define DUMP_REGISTER_FIELDS                               0
//
// Display all descriptions when dumping them
//
#define DUMP_REGISTER_DESCRIPTIONS                         0
//
// Enable to use new receive enable and fine write leveling algos. These save code space.
//
#define SPACE_OPTIMIZED_ALGOS                              1
//
// Min receive VREF
//
#define RX_VREF_MIN                                        0
//
// Max receive VREF
//
#define RX_VREF_MAX                                        30
//
// Receive VREF step
//
#define RX_VREF_STEP                                       3
//
// Min transmit VREF
//
#define TX_VREF_MIN                                        0
//
// Max transmit VREF
//
#define TX_VREF_MAX                                        63
//
// Transmit VREF step
//
#define TX_VREF_STEP                                       3
//
// Enable Stack size reduction by commented out unused variable
//
#define STACK_SIZE_REDUCE_EN                               1
//
// Enable flag internal validation SV Hooks
//
#define MEM_SV_HOOKS                                       0
//
// Minimum allowable pulse width for RCVN and FWL in 1/16 clock increments. i.e. 4 = 1/4 clock.
//
#define MIN_PULSE_WIDTH                                    2
//
// When running Rd/Wr training, use per-bit algo.
//
#define NEW_RTWT_ALGO                                      1
//
//
//
#define CPGC_BASED_READWRITES                              1
//
//
//
#define CPGC_BASED_WRITES                                  1
//
//
//
#define CPGC_BASED_READS                                   0
//
//
//
#define CPGC_BASE_EARLYREADS                               0
//
//
//
#define EARLYMPR_1DSWEEP                                   1
//
//
//
#define RX_PI_MIN_WIDTH                                    20
//
//
//
#define CTLE_MIN                                           0
//
//
//
#define CTLE_MAX                                           3
//
//
//
#define CTLE_STEP                                          1
//
//
//
#define RT_VREF_MIN                                        0
//
//
//
#define RT_VREF_MAX                                        30
//
//
//
#define RT_VREF_STEP                                       3
//
//
//
#define NUM_CONS_MIN_EWS                                   3
//
//
//
#define NUM_FINAL_VREF_SAMPLES                             7
//
//
//
#define RX_PI_MIN_EYEWIDTH                                 15
//
//
//
#define TX_PI_MIN_EYEWIDTH                                 15
//
// When doing VREF Sweep, starting value
//
#define RT_VREF_SWEEPMIN                                   0
//
//
//
#define RT_VREF_SWEEPMAX                                   30
//
//
//
#define RT_VREF_SWEEPSTEP                                  5
//
// Pi/VREF center estimate weight
//
#define MIN_WEIGHT                                         2
//
//
//
#define MID_WEIGHT                                         3
//
//
//
#define MAX_WEIGHT                                         5
//
// When doing VREF Sweep, starting value
//
#define WT_VREF_SWEEPMIN                                   0
//
//
//
#define WT_VREF_SWEEPMAX                                   30
//
//
//
#define WT_VREF_SWEEPSTEP                                  5
//
// When determing Vref Center, number of PI columns
//
#define MAX_PI_SAMPLES                                     3
//
// When determing Pi center, number Vref rows
//
#define NUM_CONS_VREFS                                     3
//
//
//
#define RX_PI_MIN                                          0
//
//
//
#define RX_PI_MAX                                          64
//
//
//
#define RX_PI_STEP                                         1
//
//
//
#define MAX_PI                                             63
//
//
//
#define RTWT_SIM                                           0
//
//
//
#define BXT_PO                                             0
//
// Tile Search Step Size
//
#define ECT_STEP_SIZE                                      5
//
// Tile Search Width
//
#define ECT_TSWIDTH                                        9
//
// Tile Search Shedding Percentage
//
#define ECT_TS_SHEDDING_PERCENT                            50
//
// Tile Search Value Limit for each Loop (To prevent overflowing integers)
//
#define ECT_TS_VAL_LIMIT                                   255
//
//
//
#define RCVN_PREAM_CLK_SUBTRACT                            3
//
//
//
#define VOC_TRAINING                                       1
//
//
//
#define VOC_LP4_VrefRMin_LDO_ENABLE                        93
//
//
//
#define VOC_LP4_VrefRMax_LDO_ENABLE                        429
//
// Voltage ; LDO on = LP4 only
//
#define VOC_LP4_VrefRMin_LDO_DISABLE                       238
//
// Voltage ; LDO on = LP4 only
//
#define VOC_LP4_VrefRMax_LDO_DISABLE                       742
//
// Voltage
//
#define VOC_LP3_VrefRMin                                   238
//
// Voltage
//
#define VOC_LP3_VrefRMax                                   742
//
// Voltage
//
#define VOC_DDR3L_VrefRMin                                 238
//
// Voltage
//
#define VOC_DDR3L_VrefRMax                                 742
//
//
//
#define VOC_Rext                                           105
//
//
//
#define VOC_VREF_MAX                                       63
//
//
//
#define VOC_VREF_STEP_SIZE                                 1
//
//
//
#define VOC_LP4_PullUpRon_LDO_ENABLE                       140
//
//
//
#define VOC_LP4_PullDnRon_LDO_ENABLE                       40
//
//
//
#define VOC_LP4_PullUpRon_LDO_DISABLE                      140
//
//
//
#define VOC_LP4_PullDnRon_LDO_DISABLE                      40
//
//
//
#define VOC_LP3_PullUpRon                                  40
//
//
//
#define VOC_LP3_PullDnRon                                  40
//
//
//
#define VOC_DDR3L_PullUpRon                                40
//
//
//
#define VOC_DDR3L_PullDnRon                                40
//
//
//
#define VOC_LP4_SegmentsEnabled_LDO_ENABLE                 2
//
//
//
#define VOC_LP4_SegmentsEnabled_LDO_DISABLE                2
//
//
//
#define VOC_LP3_SegmentsEnabled                            2
//
//
//
#define VOC_DDR3L_SegmentsEnabled                          2
//
// Enable or disable debug messages related to Max PI setup.
//
#define MAXPIDLL_DEBUG_PRINT                               0
//
//
//
#define RDCMD2RDVLD_TRAINING                               1
//
// Does this DDRIO have an analog DLL?
//
#define ANALOG_DLL_SUPPORT_BLUEPRINT_LPDDR34               0
//
// Does this project have a digital DLL?
//
#define DIGITAL_DLL_SUPPORT_BLUEPRINT_LPDDR34              1
//
// Number of delay types which use clock crossings. Sometimes this is 1 in the case of only having a PI delay. Other projects have a coarse and a fine delay, so this would be 2.
//
#define NUM_CC_DEPENDENT_ELEMENTS_BLUEPRINT_LPDDR34        1
//
// Does this DDRIO have an analog DLL?
//
#define ANALOG_DLL_SUPPORT_BLUEPRINT_DDR3                  0
//
// Does this project have a digital DLL?
//
#define DIGITAL_DLL_SUPPORT_BLUEPRINT_DDR3                 1
//
// Number of delay types which use clock crossings. Sometimes this is 1 in the case of only having a PI delay. Other projects have a coarse and a fine delay, so this would be 2.
//
#define NUM_CC_DEPENDENT_ELEMENTS_BLUEPRINT_DDR3           1

//
// Max number of registers needed to be cached for the GetSet functions.
//
#define MAX_NUM_CACHE_ELEMENTS                             50
#define MAX_NUM_CACHE_ELEMENTS_PB                          3

//
// Max number of delay types (i.e. receive enable, TX DQS, etc).
//
#define MAX_NUM_ALGOS                                      20

#endif // _MMRCPROJECTDEFINITIONSGENERATED_H_

